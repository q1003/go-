1.channel本质就是一个队列（FIFO）的数据结构，数据是先进先出的
2.多goroutine访问时，不需要加锁，也就是说channel本身就是线程安全的
3.channel是有类型的，一个string的channel只能存放一个string类型的数据结构

1）定义/声明
var 变量名 chan 数据类型
注意：channel是引用类型，必须初始化后才能写入数据，管道是有类型的
2）初始化
make(chan 数据类型,size)
3）写数据
变量名<-数据
注意：写数据时不能超过其容量（make时候定义好的）。长度是添加进来的数据
4）读取长度和容量
len(变量名) cap(变量名)
5）读数据
变量名=<-channel类型的变量名
代码例子：
package main

import (
	"fmt"
)

func main() {
	var intChan chan int
	intChan = make(chan int, 3)
	fmt.Printf("intChan的值=%v", &intChan)

	intChan <- 10
	num := 211
	intChan <- num
	fmt.Printf("channel len=%v cap=%v\n", len(intChan), cap(intChan))

	num2 := <-intChan
	num3 := <-intChan

	fmt.Printf("num2=%v num3=%v\n", num2, num3)
}
6）管道的关闭：
使用内置函数close可以关闭channel，当channel关闭后，就不能向channel写数据了，但是任然可以从该channel读取数据
7）管道的遍历：（支持for-range方式遍历）
在遍历时，如果chnnel没有关闭，则会出现deadlock错误；如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历
