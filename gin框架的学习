Gin框架
一、介绍及下载
Go世界里最流行的Web框架，Github上有32K+star。 基于httprouter开发的Web框架。 中文文档齐全，简单易用的轻量级框架。

在cmd中输入以下命令
go get -u github.com/gin-gonic/gin

Gin示例
package main
import (
	"github.com/gin-gonic/gin"
)
func main() {
	// 创建一个默认的路由引擎
	r := gin.Default()
	// GET：请求方式；/hello：请求的路径
	// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数
	r.GET("/hello", func(c *gin.Context) {
		// c.JSON：返回JSON格式的数据
		c.JSON(200, gin.H{
			"message": "Hello world!",
		})
	})
	// 启动HTTP服务，默认在8080端口启动服务
	r.Run()
}

二、RESTFUL风格
REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。

GET用来获取资源
POST用来新建资源
PUT用来更新资源
DELETE用来删除资源。

三、Gin渲染
1.HTML渲染
Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。
代码示例：
func main() {
	r := gin.Default()
	r.LoadHTMLGlob("templates/**/*")
	//r.LoadHTMLFiles("templates/posts/index.html","templates/users/index.html")
	r.GET("posts/index", func(c *gin.Context) {
		c.HTML(http.StatusOK, "posts/index.html", gin.H{
			"title": "posts/index",
		})
	})

	r.GET("users/index", func(c *gin.Context) {
		c.HTML(http.StatusOK, "users/index.html", gin.H{
			"title": "users/index",
		})
	})

	r.Run(":8080")
}

2.自定义模板函数
后端代码示例：
func main() {
	r := gin.Default()
	r.SetFuncMap(template.FuncMap{
		"safe": func(str string) template.HTML{
			return template.HTML(str)
		},
	})
	r.LoadHTMLFiles("./index.tmpl")

	r.GET("/index", func(c *gin.Context) {
		c.HTML(http.StatusOK, "index.tmpl", "<a href='https://liwenzhou.com'>李文周的博客</a>")
	})
	router.Run(":8080")
}
前端代码示例：
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>修改模板引擎的标识符</title>
</head>
<body>
<div>{{ . | safe }}</div>
</body>
</html>

注意：| 是管道操作符，用于将变量的输出传递给下一个函数或操作。
safe 是一个模板函数，它用于标记变量为“安全”，允许其中包含 HTML 标记和特殊字符，而不会被转义。

3.静态文件处理
当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用gin.Static方法即可。
代码示例：
func main() {
	r := gin.Default()
	r.Static("/static", "./static")
	r.LoadHTMLGlob("templates/**/*")
   // ...
	r.Run(":8080")
}

4.模板继承
Gin框架默认都是使用单模板，如果需要使用block template功能，可以通过"github.com/gin-contrib/multitemplate"库实现
首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中home.tmpl和index.tmpl继承了base.tmpl：
目录：
templates
├── includes
│   ├── home.tmpl
│   └── index.tmpl
├── layouts
│   └── base.tmpl

然后我们定义一个loadTemplates函数如下：
func loadTemplates(templatesDir string) multitemplate.Renderer {
	r := multitemplate.NewRenderer()//创建一个新的多模板渲染器实例
	layouts, err := filepath.Glob(templatesDir + "/layouts/*.tmpl")//使用filepath.Glob函数，根据传入的templatesDir目录路径和模式"/layouts/*.tmpl" 获取所有符合条件的布局模板文件。
	if err != nil {
		panic(err.Error())
	}
	includes, err := filepath.Glob(templatesDir + "/includes/*.tmpl")//使用 filepath.Glob 函数，根据传入的 templatesDir 目录路径和模式 "/includes/*.tmpl" 获取所有符合条件的包含模板文件。
	if err != nil {
		panic(err.Error())
	}
	// 为layouts/和includes/目录生成 templates map
	for _, include := range includes {
		layoutCopy := make([]string, len(layouts))//针对 includes 中的每个包含模板文件，创建一个临时的布局模板副本 layoutCopy
		copy(layoutCopy, layouts)//将布局模板文件路径复制到 layoutCopy 中。
		files := append(layoutCopy, include)
		r.AddFromFiles(filepath.Base(include), files...)//使用 r.AddFromFiles 方法将布局名称（通过 filepath.Base(include) 获取）和文件路径切片作为参数传入，将布局和包含模板文件添加到多模板渲染器中。
	}
	return r
}

我们在main函数中：
func indexFunc(c *gin.Context){
	c.HTML(http.StatusOK, "index.tmpl", nil)
}

func homeFunc(c *gin.Context){
	c.HTML(http.StatusOK, "home.tmpl", nil)
}

func main(){
	r := gin.Default()
	r.HTMLRender = loadTemplates("./templates")
	r.GET("/index", indexFunc)
	r.GET("/home", homeFunc)
	r.Run()
}

5.补充文件路径处理
关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。
func getCurrentPath() string {
	if ex, err := os.Executable(); err == nil {	//通过 os.Executable() 函数获取当前程序的可执行文件的路径，并将结果赋值给变量 ex。
		return filepath.Dir(ex)		//使用 filepath.Dir 函数提取 ex 的父目录路径，并返回该路径作为结果。
	}
	return "./"		//如果在执行 os.Executable() 函数时出现错误，将错误信息忽略，并通过 return 语句返回字符串 "./" 作为默认路径。
}

6.JSON格式渲染
代码示例：
func main() {
	r := gin.Default()

	// gin.H 是map[string]interface{}的缩写
	r.GET("/someJSON", func(c *gin.Context) {
		// 方式一：自己拼接JSON
		c.JSON(http.StatusOK, gin.H{"message": "Hello world!"})
	})
	r.GET("/moreJSON", func(c *gin.Context) {
		// 方法二：使用结构体
		var msg struct {
			Name    string `json:"user"`
			Message string
			Age     int
		}
		msg.Name = "小王子"
		msg.Message = "Hello world!"
		msg.Age = 18
		c.JSON(http.StatusOK, msg)
	})
	r.Run(":8080")
}

7.XML渲染
XML 渲染是指将数据以 XML（eXtensible Markup Language）的形式进行呈现和展示的过程。XML 是一种标记语言，用于描述和表示结构化数据。它使用标签（tag）来标识不同的数据元素，并使用属性（attribute）来提供关于这些元素的附加信息。XML 具有自我描述性、可扩展性和平台无关性等特点，广泛应用于数据交换和存储领域。在 XML 渲染过程中，通常会将数据结构转换为符合 XML 格式的字符串或文档，并将其发送到客户端进行显示或处理。渲染 XML 数据时，数据通常以一种层次结构的形式组织，并通过嵌套的标记和属性来表示关系和属性。XML 渲染可以用于各种用途，包括生成动态网页、数据交换、配置文件生成等。在应用程序中，可以使用编程语言或专门的 XML 处理库来进行 XML 数据的渲染和解析。这样可以实现将结构化数据以一种易于理解和处理的方式进行表示和分享。

代码示例：
func main() {
	r := gin.Default()
	// gin.H 是map[string]interface{}的缩写
	r.GET("/someXML", func(c *gin.Context) {
		// 方式一：自己拼接JSON
		c.XML(http.StatusOK, gin.H{"message": "Hello world!"})
	})
	r.GET("/moreXML", func(c *gin.Context) {
		// 方法二：使用结构体
		type MessageRecord struct {
			Name    string
			Message string
			Age     int
		}
		var msg MessageRecord
		msg.Name = "小王子"
		msg.Message = "Hello world!"
		msg.Age = 18
		c.XML(http.StatusOK, msg)
	})
	r.Run(":8080")
}

8.YAML渲染
YAML 渲染是指将数据以 YAML（YAML Ain’t Markup Language）的格式进行呈现和展示的过程。YAML 是一种人类友好的数据序列化格式，通常用于配置文件和数据交换。与 XML 和 JSON 不同，YAML 的语法着重于易读性和简洁性。它使用空白字符和缩进来表示层次结构，并通过冒号和换行符来表示键-值对。在 YAML 渲染过程中，通常会将数据转换为符合 YAML 格式的字符串，以便于读取和处理。渲染 YAML 数据时，数据通常以一个键-值对的方式组织，并通过缩进来表示层次结构。YAML 渲染可以用于各种用途，包括生成配置文件、定义数据结构和创建人类可读的数据格式。在应用程序中，可以使用编程语言或专门的 YAML 处理库来进行 YAML 数据的渲染和解析。这样可以实现将复杂数据以一种简洁、易读的格式进行表示和交换。

部分代码示例：
r.GET("/someYAML", func(c *gin.Context) {
	c.YAML(http.StatusOK, gin.H{"message": "ok", "status": http.StatusOK})
})

9.Protobuf渲染
Protobuf（Protocol Buffers）是一种跨平台、语言无关、高效的数据序列化格式。与 XML 和 JSON 类似，Protobuf 用于在不同的系统之间进行数据交换和存储。Protobuf 渲染是指将数据以 Protobuf 的格式进行呈现和展示的过程。在 Protobuf 渲染过程中，首先需要定义数据的消息结构，即使用 Protobuf 的语法定义数据结构和字段。然后，使用相应的编译器将这些消息结构定义编译成对应语言的源代码文件。根据编译后的源代码，开发者可以使用编程语言提供的 Protobuf 库进行数据序列化和反序列化操作。Protobuf 渲染将数据转换为二进制格式，这种格式相对于文本格式（如 JSON）更加紧凑和高效。它适用于在网络传输、持久化存储等场景下，可以节省带宽和存储空间。在应用程序中，可以使用编程语言提供的 Protobuf 库来进行 Protobuf 数据的渲染和解析。这样可以将结构化数据以高效、紧凑的方式进行表示和交换，适用于大规模数据处理和分布式系统。

代码示例：
r.GET("/someProtoBuf", func(c *gin.Context) {
	reps := []int64{int64(1), int64(2)}
	label := "test"
	// protobuf 的具体定义写在 testdata/protoexample 文件中。
	data := &protoexample.Test{
		Label: &label,
		Reps:  reps,
	}
	// 请注意，数据在响应中变为二进制数据
	// 将输出被 protoexample.Test protobuf 序列化了的数据
	c.ProtoBuf(http.StatusOK, data)
})

四、获取参数
1.获取querystring参数
querystring指的是URL中?后面携带的参数，例如：/user/search?username=小王子&address=沙河。 获取请求的querystring参数的方法如下：

func main() {
	//Default返回一个默认的路由引擎
	r := gin.Default()
	r.GET("/user/search", func(c *gin.Context) {
		username := c.DefaultQuery("username", "小王子")	//用于获取 HTTP 请求中的查询参数 username 的值。如果查询参数中没有提供 username 参数，或者其值为空，则会返回默认值 "小王子"。
		//username := c.Query("username")
		address := c.Query("address")
		//输出json结果给调用方
		c.JSON(http.StatusOK, gin.H{
			"message":  "ok",
			"username": username,
			"address":  address,
		})
	})
	r.Run()
}

2.获取form参数
当前端请求的数据通过form表单提交时，例如向/user/search发送一个POST请求，获取请求数据的方式如下：
func main() {
	//Default返回一个默认的路由引擎
	r := gin.Default()
	r.POST("/user/search", func(c *gin.Context) {
		// DefaultPostForm取不到值时会返回指定的默认值
		//username := c.DefaultPostForm("username", "小王子")
		username := c.PostForm("username")
		address := c.PostForm("address")
		//输出json结果给调用方
		c.JSON(http.StatusOK, gin.H{
			"message":  "ok",
			"username": username,
			"address":  address,
		})
	})
	r.Run(":8080")
}
